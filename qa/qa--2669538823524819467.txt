
            message = 'FastAPI Code:\n@app.post("/login")\ndef login(user_in: UserIn, db: Session = Depends(get_db)):\n    try:\n        # Generate a random 4-digit OTP\n        otp = random.randint(1000, 9999)\n\n        # Create a new user instance\n        user = User(email=user_in.email, otp=otp)\n\n        # Add the user to the session and commit\n        db.add(user)\n        db.commit()\n\n        return {"message": "Success"}\n    except Exception as e:\n        # If anything goes wrong, rollback changes\n        db.rollback()\n        print(str(e))\n        raise HTTPException(status_code=400, detail="Failure: " + str(e))\n\n\nThis is creating a user every time. That is wrong.\n\nI want it to create a user if it is not present and update the OTP if it is present'

            response = 'To modify your FastAPI endpoint to check if a user exists before creating a new one, and update the existing user\'s OTP if they already exist, you can adjust your code as follows:\n\n1. Query the database to check if the user already exists by their email.\n2. If the user exists, update the OTP.\n3. If the user does not exist, create a new user.\n4. Commit changes to the database accordingly.\n\nHere\'s how you can implement these steps:\n\n```python\nfrom fastapi import FastAPI, HTTPException, Depends\nfrom sqlalchemy.orm import Session\nimport random\nfrom models import User   # Import your User model\nfrom schemas import UserIn  # Import your UserIn schema (replace with actual import based on your project setup)\nfrom database import get_db  # Import the get_db dependency (replace with actual import based on your project setup)\n\napp = FastAPI()\n\n@app.post("/login")\ndef login(user_in: UserIn, db: Session = Depends(get_db)):\n    try:\n        # Query the database to find the user by email\n        user = db.query(User).filter(User.email == user_in.email).first()\n\n        # Generate a random 4-digit OTP\n        otp = random.randint(1000, 9999)\n\n        if user:\n            # If the user exists, update the OTP\n            user.otp = otp\n        else:\n            # If the user does not exist, create a new user\n            user = User(email=user_in.email, otp=otp)\n            db.add(user)\n\n        # Committing the changes to the database\n        db.commit()\n\n        return {"message": "Success"}\n    except Exception as e:\n        # In case of any exceptions, rollback the changes\n        db.rollback()\n        print(str(e))\n        raise HTTPException(status_code=400, detail="Failure: " + str(e))\n\n# Ensure your User model, UserIn schema, and database connection logic (get_db) are correctly implemented\n```\n\nMake sure you have the appropriate imports for your `User` model, `UserIn` schema, and `get_db` session dependency, and adjust the code to match actual implementation details of those components in your application.\n\nHere\'s what each part of the code does:\n- The `db.query(User).filter(User.email == user_in.email).first()` statement queries the database for a user with the given email. If the user exists, it returns that user; otherwise, it returns `None`.\n- If the user exists (`if user:`), it updates the existing user\'s OTP.\n- If the user doesn\'t exist (`else:` part), it adds a new user to the database.\n- `db.commit()` commits the transaction to the database.\n- In case of any exceptions during this process, the transaction is rolled back, and an HTTP 400 error is raised with a detail message.\n\nThis approach ensures that the user\'s data is updated if they exist, and a new user is created only if they don\'t already exist in the database.'
            